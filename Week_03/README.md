一、递归
思维要点：
    1、不要人肉进行递归

    2、找到最近最简单的方法，将其拆解为可重复解决的为（重复子问题）

    3、数学归纳法思维

重点练习：
    1、自顶向下的编程方法

实战题目：
    1、爬楼梯
        a. 推导递推公式：F(n) = F(n - 1) + F(n - 2)  
        b.LeetCode官方视频中的解法： 
            1) 递归：      时间复杂度O(2^n),空间复杂度O(n)
                代码位置：Week_03/ClimbStairs.climbStairs_01
                分析：因为出现了重复计算的问题，俗称傻递归。
            2) 记忆递归：  将计算过的递归数记录下来；时间复杂度降为O(n)
                代码位置：Week_03/ClimbStairs.climbStairs_02
                分析：基于1)中重复计算的问题，将已计算过的数值缓存起来。
                记录：编码时利用覃老师自顶向下的编码方式，编写递归时: 第一步先写终止条件；第二步编写处理逻辑；第三步写递归调用
                      
            3) 动态规划：
                int num = 1, n1 = 0,n2 = 0;
                     指针从 1 开始：进入循环后，要先交换后求和
                         i:  0  0   1  2   3   4   5   6   7   8...
                       num:         1  2   3   5   8   13  21  34
                       i=1: n1  n2 num  --> n1 = n2; 
                                            n2=num;
                                            num = n1 + n2
                    指针从 3 开始：先求和后交换
            4) 斐波那契数列矩阵
            5) Binet's Formula
    
    2、括号生成
        想的不是很清楚，先背覃老师的代码

    3、翻转二叉树
        唯一一个读到题 5分钟内写出来的
        1) 递归
            终结条件是节点为null时返回
            业务处理是左右节点交换
            递归：当左节点不为空时进入递归
                  当右节点不为空时进入递归
            代码位置：InvertTree.invertTree
    4、验证二叉搜索树
        概念：a.节点的左子树只包含小于当前节点的数
             b. 节点的右子树只包含大于当前节点的数
             c. 所有的子树也必须是二叉搜索树

        读题之后，自认为理解题意便开始动手写代码，提交leetcode失败，查找原因之后发现自己对二叉搜索树的概念理解的不清楚。
        如概念a中述，节点的左子树只包含小于当前节点的数，不是左子节点，是左子树。不只是要跟当前节点比较，

    5、二叉树的最大深度
        递归：从叶子节点开始计数
    
作业：
    1、二叉树的最近公共祖先
        先写出递归模板：1、终止条件；2、业务处理；3递归调用；4、打扫战场
        关键思路：将左右递归结果返回给上一层，由上一层合并左右递归结果与本层的结果；周而复始

        代码位置：LowestCommonAncestor.lowestCommonAncestor

    2、从前序与中序遍历序列构造二叉树
        关键点：左右子树的下标计算

        代码位置：BuildTree.buildTree
    
    


